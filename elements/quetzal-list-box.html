<link rel="import" href="../../tools/polymer/polymer-elements/polymer-selector/polymer-selector.html">

<polymer-element name="quetzal-list-box" extends="polymer-selector">

<template>

<style>
@host {

  :scope {
    display: block;
    outline: none;
    overflow-y: auto;
  }

  /* Generic appearance */
  /*&.generic {*/
  :scope {
    border: 1px solid lightgray;
    box-sizing: border-box;
    cursor: default;
  }

}

::-webkit-distributed(> *) {
  box-sizing: border-box;
  display: block;
  padding: 0.25em;
  -webkit-user-select: none;
  user-select: none;
}

::-webkit-distributed(.polymer-selected) {
  background: highlight;
  color: highlighttext;
}

</style>

<shadow></shadow>
</template>

<script>
Polymer( "quetzal-list-box", {

  ready: function() {
    this.super();
    if ( this.tabIndex == -1 /* Default value */ ) {
      // Try to convince the browser that the list is focusable, but without
      // forcing it into the tab order (as a positive tabindex would do).
      // Firefox, Chrome, and IE seem to handle this as desired if tabindex is
      // (explicitly) set to a negative number.
      this.tabIndex = -1;
    }
    this.addEventListener( "keydown", function( event ) {
      this._keydown( event );
    }.bind( this ));
  },

  // TODO: Handle valueattr: selected indicates a value, not the index.
  get selectedIndex() {
    var index = this.selected;
    return index;
  },
  set selectedIndex( index ) {
    this.selected = index;
  },

  selectFirstItem: function() {
    if ( this.items.length > 0 ) {
      this.selectedIndex = 0;
      // The list will have already scrolled the first element into view, but if
      // the list has top padding, the scroll won't be all the way at the top.
      // So, as a special case, force it to scroll to the top.
      this.scrollTop = 0;
      return true;
    } else {
      return false;
    }
  },

  selectLastItem: function() {
    if ( this.items.length > 0 ) {
      this.selectedIndex = this.items.length - 1;
      return true;
    } else {
      return false;
    }
  },

  selectNextItem: function() {
    var index = this.selectedIndex + 1;
    if ( index < this.items.length ) {
      this.selectedIndex = index;
      return true;
    } else {
      return false;
    }
  },

  selectPreviousItem: function() {
    var index = this.selectedIndex - 1;
    if ( index >= 0 && this.items.length > 0 ) {
      this.selectedIndex = index;
      return true;
    } else {
      return false;
    }
  },

  // TODO: This should override selectedItem instead of valueToSelection.
  // File bug report to expose selectedItem as attribute.
  valueToSelection: function( value ) {
    this.super( arguments );
    this._scrollElementIntoView( this.selectedItem );
  },

  _keydown: function( event ) {
    var handled = false;
    switch ( event.keyCode ) {
      // case 33: // Page Up
      //   handled = this._pageUp();
      //   break;
      // case 34: // Page Down
      //   handled = this._pageDown();
      //   break;
      case 35: // End
        handled = this.selectLastItem();
        break;
      case 36: // Home
        handled = this.selectFirstItem();
        break;
      // case 37: // Left
      //   if (this.selectedItemIsInline()) {
      //     handled = this.selectPreviousItem();
      //   }
      //   break;
      case 38: // Up
        handled = event.altKey ? this.selectFirstItem() : this.selectPreviousItem();
        break;
      // case 39: // Right
      //   if (this.selectedItemIsInline()) {
      //     handled = this.selectNextItem();
      //   }
      //   break;
      case 40: // Down
        handled = event.altKey ? this.selectLastItem() : this.selectNextItem();
        break;
      default:
        handled = false;
    }
    if ( handled ) {
      event.preventDefault();
      return false;
    }
  },

  // Scroll the given element completely into view, minimizing the degree of
  // scrolling performed.
  //
  // Blink has a scrollIntoViewIfNeeded() function that almost does what we
  // want, but unfortunately it's non-standard, and in any event often ends up
  // scrolling more than is absolutely necessary.
  _scrollElementIntoView: function( element ) {
    // Get the relative position of the element with respect to the top of the
    // list's scrollable canvas. An element at the top of the list will have a
    // elementTop of 0.
    var elementTop = element.offsetTop - this.offsetTop - this.clientTop;
    var elementBottom = elementTop + element.offsetHeight;
    // Determine the bottom of the scrollable canvas.
    var scrollBottom = this.scrollTop + this.clientHeight;
    if ( elementBottom > scrollBottom ) {
      // Scroll up until element is entirely visible.
      this.scrollTop += elementBottom - scrollBottom;
    } else if ( elementTop < this.scrollTop ) {
      // Scroll down until element is entirely visible.
      this.scrollTop = elementTop;
    }
  }

});
</script>

</polymer-element>
