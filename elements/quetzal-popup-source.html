<!--
An element whose content is associated with a popup. This element does two jobs:
1) Open the popup when the element content is tapped.
2) Position the popup below or above the content as appropriate.
-->

<link rel="import" href="quetzal-element.html">
<link rel="import" href="quetzal-popup.html">

<polymer-element name="quetzal-popup-source" extends="quetzal-element" attributes="closeOnInsideClick opened openOnClick openOnFocus">

<template>

<style>
:host {
  display: inline-block;
}

#positioner {
  position: relative;
}

#popup {
  position: absolute;
}

#container {
  -webkit-user-select: none;
  user-select: none;
}
</style>

<div id="positioner">
  <quetzal-popup id="popup" opened="{{opened}}" tabindex="-1">
    <content select="property[name='popup']"></content>
  </quetzal-popup>
  <!--
  BUG: The container of the real content of the popup source (the thing you can
  click on to open the popup) should go before the popup so that it can get
  covered by the popup. Unfortunately, a limitation on the use of a plain
  content element means that it has to go last (so that the popup property gets
  appropriately distributed to the popup via the select attribute).
  -->
  <div id="container">
    <content></content>
  </div>
</div>

</template>

<script>
Polymer( "quetzal-popup-source", {

  close: Quetzal.alias( "$.popup.close" ),

  created: function() {

    this.super();
    this.$.container.addEventListener( "mousedown", function( event ) {
      this.log( "mousedown" );
      if ( this.openOnMouseDown && !this.opened ) {
        // this._suppressAutoCloseUntilNextTap();
        this.open();
      }
    }.bind( this ));
    // HACK: The base polymer-overlay element listens for "tap" events to
    // determine when to auto-close the popup. Unfortunately, a single click/tap
    // on a popup-source will both open the popup (on the mousedown) and then
    // immediately close it (on the mouseup). For now, we hack around this by
    // always suppressing auto-close until we've received the first tap event.
    this.$.container.addEventListener( "tap", function( event ) {
      this.log( "tap" );
      // this._restoreAutoClose();
    }.bind( this ));
    this._focusContainer.addEventListener( "focusin", function() {
      this.log( "focusin" );
      if ( this.openOnFocus && !this.opened ) {
        this.log( "opening on focus" );
        this.open();
      }
    }.bind( this ));
    this.shadowRoot.addEventListener( "polymer-overlay-open", function() {
      if ( this.opened ) {
        this.log( "opened" );
        this.positionPopup();
      }
    }.bind( this ));
  },

  open: Quetzal.alias( "$.popup.open" ),

  openOnFocus: false,

  openOnMouseDown: true,

  positionPopup: function() {
    var rect = this.$.container.getBoundingClientRect();
    var top = rect.top;
    var left = rect.left;
    var height = rect.height;
    var width = rect.width;
    var bottom = rect.bottom;
    var right = rect.right;
    var popup = this.$.popup;
    var popupHeight = popup.offsetHeight;
    var popupWidth = popup.offsetWidth;
    var scrollTop = 0;
    var scrollLeft = 0;
    var viewportHeight = window.innerHeight;
    var viewportWidth = window.innerWidth;
    var popupFitsBelow = bottom + popupHeight <= viewportHeight + scrollTop;
    var popupFitsAbove = top - popupHeight >= scrollTop;
    var popupAppearsBelow = popupFitsBelow || !popupFitsAbove;
    var popupTop = popupAppearsBelow ? height : -popupHeight;
    var popupFitsLeftAligned = left + popupWidth <= viewportWidth + scrollLeft;
    var popupFitsRightAligned = right - popupWidth >= scrollLeft;
    var popupAlignLeft = popupFitsLeftAligned || !popupFitsRightAligned;
    var popupLeft = popupAlignLeft ? 0 : width - popupWidth;
    popup.style.top = popupTop + "px";
    popup.style.left = popupLeft + "px";
    var classList = popup.classList;
    classList.toggle( "popupAppearsAbove", !popupAppearsBelow );
    classList.toggle( "popupAppearsBelow", popupAppearsBelow );
    classList.toggle( "popupAlignLeft", popupAlignLeft );
    classList.toggle( "popupAlignRight", !popupAlignLeft );
  },

  toggle: Quetzal.alias( "$.popup.toggle" ),

  _autoCloseDisabled: null,

  // This returns the element used to listen to focusin events. Subclasses can
  // override this if they only want to listen to focusin from within a specific
  // sub-element.
  get _focusContainer() {
    return this.$.container;
  },

  // REVIEW: Some portion of these can probably get folded into openOnMouseDown
  // support within quetzal-popup itself.
  _restoreAutoClose: function() {
    if ( this._autoCloseDisabled != null ) {
      this.log( "restoring autoCloseDisabled" );
      this.$.popup.autoCloseDisabled = this._autoCloseDisabled;
      if ( !this.autoCloseDisabled ) {
        this.log( "enabling capture handler" )
        this.$.popup.enableCaptureHandler( this.opened );
      }
      // Ensure subsequent calls to _restoreAutoClose will have no effect.
      this._autoCloseDisabled = null;
    }
  },

  _suppressAutoCloseUntilNextTap: function() {
    // Save the current state of the popup's autoCloseDisabled attribute.
    this._autoCloseDisabled = this.$.popup.autoCloseDisabled;
    // Override the current setting and disable auto-close.
    this.$.popup.autoCloseDisabled = true;
  }

});
</script>

</polymer-element>
